# Useful functions loaded in fpath

# Load thefuck
if command -v thefuck >/dev/null 2>&1; then
  fuck() {
    eval $(thefuck --alias) && fuck
  }
fi

# dir stack
d() {
  if [ -n $1 ]; then
    dirs "$@"
  else
    dirs -v | head -10
  fi
}

# Make directory and cd into it
function take() { 
	mkdir -p $1
	cd $1
}

# Find file containing a string
findstr() {
	if [ $# -eq 1 ]; then
		find . -type f -exec grep -r --exclude \*.zsh_hist "$1" /dev/null {} \; # Current directory
	elif [ $# -eq 2 ]; then
		find "$1" -type f -exec grep -r --exclude \*.zsh_hist "$2" /dev/null {} \; # Directory specified in 1st arg
	fi
}

# Backup file
bu() {
	if [[ $# -eq 1 && $1 == log ]]; then
		cat "$ZSH"/.zbulog # Print backup file log
	elif [[ $# -eq 1 && $1 == logclear ]]; then
		echo -n "" > "$ZSH"/.zbulog # Clear backup file log
		echo "Cleared backup log file."
	else
		mv "$1" "$1".bak_"$(date +%Y%m%d%H%M%S)" # Backup file with date in filename
		cp -ip "$1".bak_"$(date +%Y%m%d%H%M%S)" "$1" # Copy backup and use original filename
		if [[ $# -eq 2 && $2 == log ]]; then
			echo "$(date "+%Y-%m-%d %T") bu: $PWD/$1" >> "$ZSH"/.zbulog
		fi
	fi
}

# Git add file/s, commit message and push.
gacp() {
	if [ $# -eq 1 ]; then
		git add -A
		git commit -m $1
	else
		git add $1
		git commit -m $2
	fi
	git push
}

# Git undo last commit
gcu() {
	git reset HEAD^
	git push -f
}

# Extract archives
extract(){
	if [[ -z "$1" ]] ; then
		print -P "Extract an archive based on the file extension"
		print -P "Usage: \e[1;36mextract\e[1;0m [filename]"
	elif [[ -f $1 ]] ; then
		case ${(L)1} in
			*.tar.xz)   tar -Jxf $1		;;
			*.tar.bz2)  tar -jxvf $1	;;
			*.tar.gz)   tar -zxvf $1	;;
			*.bz2)      bunzip2 $1		;;
			*.gz)       gunzip $1		;;
			*.jar)      unzip $1		;;
			*.rar)      unrar x $1		;;
			*.tar)      tar -xvf $1		;;
			*.tbz2)     tar -jxvf $1	;;
			*.tgz)      tar -zxvf $1	;;
			*.zip)      unzip $1		;;
			*.Z)        uncompress $1	;;
			*.7z)       7za e $1		;;
			*)          echo "Unable to extract '$1' :: Unknown extension"
		esac
	else
		echo "File ('$1') does not exist!"
	fi
}

# Run job silently in the background on a random schedule
timer() {
	local tMin tMax rand randt
	((tMin=$1*3600)) # Convert Min hrs to sec
	((tMax=$2*3600)) # Convert Max hrs to sec
	((rand=tMin+RANDOM%(1+tMax-tMin))) # Generate random time between Min and Max
	((randt=$rand*100)) # Convert to hundreths sec for zselect
	zmodload zsh/zselect
	zselect -t $randt # Sleep for random time
	## Command to run
	fortune
	##
	silentjob # Loop job
}
silentjob() {
	[ $UID -eq 0 ] && return # No silent job for root user
	if [ -n "$PROMPT_RJOB" ]; then
		setopt local_options no_monitor no_notify # Prevent job status for this function only
		{ timer 4 8 } & # Args: Max and Min hrs for timer
		disown &>/dev/null # Disown background job
	fi
}
silentjob

# Color chart
bgc() {
	for i in {0..255}; do printf '\e[48;5;%dm%3d ' $i $i; (((i+3) % 18)) || printf '\e[0m\n'; done # Background
}
fgc() {
	for i in {0..255}; do printf '\e[38;5;%dm%3d ' $i $i; (((i+3) % 18)) || printf '\e[0m\n'; done # Foreground
}

# Display message below prompt - zplugin builtin
deploymsg() {
	typeset -g dmsg=1
	-zplg-deploy-message "$@"
}

# Local weather
weather() { curl -s wttr.in | sed -n 1,7p }
forecast() { curl -s wttr.in | sed -n 8,37p }

# Keybind functions
clear_screen() {	# [Ctrl+L] - Clear screen and unset variables
	[ -n $paste ] && unset paste
	[ -n $retcode ] && unset retcode
	[ -n $timer_result ] && unset timer_result
	[ -n $__searching ] && unset __searching
	[ -n $dmsg ] && unset dmsg
	zle .clear-screen
}
zle -N clear_screen_widget clear_screen
bindkey '^L' clear_screen_widget

kill_line() {		# [Ctrl+U] - Kill line and unset variables
	[ -n $paste ] && unset paste
	[ -n $__searching ] && unset __searching
	zle .kill-whole-line
}
zle -N kill_line_widget kill_line
bindkey '^U' kill_line_widget

fancy_ctrl_z() {	# [Ctrl+Z] - Suspend and return job/buffer
	if [ $#BUFFER -eq 0 ]; then
		fg
		BUFFER=""
		zle .redisplay
	else
		zle .push-input
	fi
}
zle -N fancy_ctrl_z
bindkey '^Z' fancy_ctrl_z

nano_cmdline () {	# [Ctrl+X,E] - Edit command line in nano
	local VISUAL='nano -Y sh'
	edit-command-line
}
zle -N nano_cmdline
bindkey '^X^E' nano_cmdline

# Auto activate/deactivate virtual environment
auto_venv() {
	[ -n "$PROMPT_VENV" ] || return
	if [ -z "$VIRTUAL_ENV" ]; then
		local venvname=venv # Set to your usual virtual env directory name
		# Or you can search the current directory for the virtualenv name - Disabled by default
		#for i in $(find . -maxdepth 1); do
		#	if [ -f ./"$i"/bin/activate ]; then
		#		local venvname="$i"
		#	fi
		#done
		VIRTUAL_ENV_DISABLE_PROMPT=1 # Disable default virtualenv PS1 to only use in prompt
		[ -f ./$venvname/bin/activate ] && source ./$venvname/bin/activate 
	else
		local venvdir=${VIRTUAL_ENV##*/}
		[ "$PWD" != "$venvdir" ] && deactivate 2>/dev/null
	fi	
}
chpwd_functions+=(auto_venv) # Add to chpwd function

# Customize accept-line
accept-line() {
	if [[ -z $BUFFER || -n $BUFFER ]]; then # Buffer is empty/set
		[ -n $paste ] && unset paste
		[ -n $timer_result ] && unset timer_result
		[ -n $__searching ] && unset __searching
		[ -n $dmsg ] && unset dmsg
	fi
	if [[ $BUFFER = *(nano|vi|less|hist|man|ssh|suroot)* ]]; then # Buffer contains these programs
		typeset -g nocmdtime=1 # Blacklist programs from CMDTIME
	else
		unset nocmdtime
	fi
	zle .accept-line # Run builtin accept-line
}
zle -N accept-line

# Print a usage for these functions
funcs() {
	print "## Useful functions loaded in fpath ##"
	print "Usage: Run the function name below\n"

	print "d		Show directory stack. Set to 'dirs -v' in aliases.\n"

	print "take 		Make directory and cd into it. This is aliased to 't'\n"

	print "bgc		Print background color chart"
	print "fgc		Print foreground color chart\n"

	print "bu		Backup a file with a timestamp and create a copy with preserved attributes"
	print "Usage: 		bu [filename] [log]"
	print " or		bu [log|logclear]"
	print "Options:"
	print " filename	Filename to backup"
	print " log [arg1] 	Print backup log"
	print " log [arg2] 	(Optional) log backup date and filename to "$ZSH"/.zbulog"
	print " logclear	Clear backup log\n"

	print "deploymsg	Display a message below the prompt. This is calling a Zplugin builtin function.\n"

	print "extract		Extract an archive based on the file extension"
	print "Usage: 		extract [filename]\n"

	print "findstr		Find a file containing a string"
	print "Usage: 		findstr [directory] [string]"
	print "Options:"
	print " directory	(Optional) directory to search. If not used then current directory is used."
	print " string 	String to search\n"

	print "gacp		Git add file, commit a message and push with one command."
	print "Usage:		gacp [filename] [message]"
	print "Options:"
	print " filename	(Optional) files to add. If not used then all modified files are added (git add -A)"
	print " commitmessage	Message for commit. Recommened to quote the message.\n"

	print "gcu 		Git undo last commit and return HEAD to previous state\n"

	print "weather		Show the current weather conditions using wttr.in"		
	print "forecast	Show the weather forecast using wttr.in\n"

	print "## Keybind functions\n"

	print "clear_screen()	[Ctrl+L] Customize builtin clear-screen widget to assist with prompt tasks"
	print "kill_line()	[Ctrl+U] Customize builtin kill-line widget to assist with prompt tasks"
	print "fancy_ctrl_z()	[Ctrl+Z] Move current program to background/foreground"
	print "nano_cmdline()	[Ctrl+X, E] Edit prompt in nano\n"

	print "## Functions automatically loaded and not user invoked\n"

	print "accept-line()	Customize builtin accept-line widget to assist with prompt tasks"
	print "auto_venv()	Auto activate/deactivate virtual environment when cd-ing into/out of a virtualenv"
	print "fuck()		Load thefuck plugin"
	print "silentjob()	Load a silent background job to run on a random schedule - runs fortune\n"
}
