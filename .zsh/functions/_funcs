# Useful functions loaded in fpath

# Load thefuck
if command -v thefuck >/dev/null 2>&1; then
	fuck() {
		eval $(thefuck --alias) && fuck
	}
fi

# Show/add to directory stack
d() {
	[ -n "$1" ] &&	dirs "$@" || dirs -v | head -10
}

# Make a directory and cd into it
mkcd() {
	[ -n "$1" ] && mkdir -p "$1" && builtin cd "$1"
}

# Change to a directory and list contents
cdls() {
	builtin cd "$argv[-1]" && ls -al "${(@)argv[1,-2]}"
}

# Remove .DS_Store files recursively in a directory - default .
rmdss() {
	find "${@:-.}" -type f -name ".DS_Store" -print -delete
}

# Find file containing a string
findstr() {
	if [ $# -eq 1 ]; then
		find . -type f -exec grep -r --exclude \*.zsh_hist "$1" /dev/null {} \; # Current directory
	elif [ $# -eq 2 ]; then
		find "$1" -type f -exec grep -r --exclude \*.zsh_hist "$2" /dev/null {} \; # Directory specified in 1st arg
	fi
}

# Backup file
bu() {
	if [[ $# -eq 1 && $1 == log ]]; then
		cat "$ZSH"/.zbulog # Print backup file log
	elif [[ $# -eq 1 && $1 == logclear ]]; then
		echo -n "" > "$ZSH"/.zbulog # Clear backup file log
		echo "Cleared backup log file."
	else
		mv "$1" "$1".bak_"$(date +%Y%m%d%H%M%S)" # Backup file with date in filename
		cp -ip "$1".bak_"$(date +%Y%m%d%H%M%S)" "$1" # Copy backup and use original filename
		if [[ $# -eq 2 && $2 == log ]]; then
			echo "$(date "+%Y-%m-%d %T") bu: $PWD/$1" >> "$ZSH"/.zbulog
		fi
	fi
}

# Git add file/s, commit message and push.
gacp() {
	if [ $# -eq 1 ]; then
		git add -A
		git commit -m $1
	else
		git add $1
		git commit -m $2
	fi
	git push
}

# Git undo last commit
gcu() {
	git reset HEAD^
	git push -f
}

# Extract archives
extract(){
	if [[ -z "$1" ]] ; then
		print -P "Extract an archive based on the file extension"
		print -P "Usage: \e[1;36mextract\e[1;0m [filename]"
	elif [[ -f $1 ]] ; then
		case ${(L)1} in
			*.tar.xz)   tar -Jxf $1		;;
			*.tar.bz2)  tar -jxvf $1	;;
			*.tar.gz)   tar -zxvf $1	;;
			*.bz2)      bunzip2 $1		;;
			*.gz)       gunzip $1		;;
			*.jar)      unzip $1		;;
			*.rar)      unrar x $1		;;
			*.tar)      tar -xvf $1		;;
			*.tbz2)     tar -jxvf $1	;;
			*.tgz)      tar -zxvf $1	;;
			*.zip)      unzip $1		;;
			*.Z)        uncompress $1	;;
			*.7z)       7za e $1		;;
			*)          echo "Unable to extract '$1' :: Unknown extension"
		esac
	else
		echo "File ('$1') does not exist!"
	fi
}

# Run job on a random schedule
randtimer() {
	local tMin tMax rand randt
	tMin=4 # Lower bound in hrs
	tMax=8 # Higher bound in hrs
	((rand=RANDOM%(tMax-tMin+1)+tMin)) # Generate a random number between bounds
	((randt=rand*360000)) # Convert random number to hundreths of sec
	zmodload zsh/zselect
	zselect -t $randt # Sleep for random time
	## Command to run
	fortune
	##
	silentjob # Loop job
}
# Run job silently in the background. Runs in an interactive shell and only in first TTY.
silentjob() {
	if [ -n "$PROMPT_RJOB" ]; then
		[ $UID -eq 0 ] && return # No silent job for root user
		[ ${TTY: -1} -gt 0 ] && return # Only deploy job in primary TTY
		setopt local_options no_monitor # Prevent job status for this function only
		{ randtimer } &! # Run a disowned background job
	fi
}
silentjob

# Color chart
bgc() {
	for i in {0..255}; do printf '\e[48;5;%dm%3d ' $i $i; (((i+3) % 18)) || printf '\e[0m\n'; done # Background
}
fgc() {
	for i in {0..255}; do printf '\e[38;5;%dm%3d ' $i $i; (((i+3) % 18)) || printf '\e[0m\n'; done # Foreground
}

# Display message below prompt - zplugin builtin
deploymsg() {
	typeset -g dmsg=1
	-zplg-deploy-message "$@"
}

# Local weather
weather() { curl -s wttr.in | sed -n 1,7p }
forecast() { curl -s wttr.in | sed -n 8,37p }

# Time zsh startup
zsht() {
	local ZSHBIN=$(which zsh)
	time $ZSHBIN -i -c exit
}

# Keybind functions
clear_screen() {	# [Ctrl+L] - Clear screen and unset variables
	[ -n $paste ] && unset paste
	[ -n $retcode ] && unset retcode
	[ -n $timer_result ] && unset timer_result
	[ -n $__searching ] && unset __searching
	[ -n $dmsg ] && unset dmsg
	zle .clear-screen
}
zle -N clear_screen_widget clear_screen
bindkey '^L' clear_screen_widget

kill_line() {		# [Ctrl+U] - Kill line and unset variables
	[ -n $paste ] && unset paste
	[ -n $__searching ] && unset __searching
	zle .kill-whole-line
}
zle -N kill_line_widget kill_line
bindkey '^U' kill_line_widget

fancy_ctrl_z() {	# [Ctrl+Z] - Suspend and return job/buffer
	if [ $#BUFFER -eq 0 ]; then
		fg
		BUFFER=""
		zle .redisplay
	else
		zle .push-input
	fi
}
zle -N fancy_ctrl_z
bindkey '^Z' fancy_ctrl_z

nano_cmdline() {	# [Ctrl+X,E] - Edit command line in nano
	local VISUAL='nano -Y sh'
	edit-command-line
}
zle -N nano_cmdline
bindkey '^X^E' nano_cmdline

scroll_pgup() {		# [Ctrl+K] - Pgup half a page and keep scrollback
	local page
	((page=$LINES/2)) # Half of Terminal lines
	for i in {1..$page}; do
		print ''
	done
	tput cup $(($page-1)) # First line position is 0
}
zle -N scroll_pgup
bindkey '^K' scroll_pgup

# Auto activate/deactivate virtual environment
auto_venv() {
	[ -n "$PROMPT_VENV" ] || return
	if [ -z "$VIRTUAL_ENV" ]; then
		local venvname=venv # Set to your usual virtual env directory name
		# Or you can search the current directory for the virtualenv name - Disabled by default
		#for i in $(find . -maxdepth 1); do
		#	if [ -f ./"$i"/bin/activate ]; then
		#		local venvname="$i"
		#	fi
		#done
		local VIRTUAL_ENV_DISABLE_PROMPT=1 # Disable default virtualenv PS1 to only use in custom prompt
		[ -f ./$venvname/bin/activate ] && source ./$venvname/bin/activate
	else
		local venvdir=${VIRTUAL_ENV##*/}
		[ "$PWD" != "$venvdir" ] && deactivate 2>/dev/null
	fi
}
chpwd_functions+=(auto_venv) # Add to chpwd function

# Customize accept-line
accept-line() {
	if [[ -z $BUFFER || -n $BUFFER ]]; then # Buffer is empty/set
		[ -n $paste ] && unset paste
		[ -n $timer_result ] && unset timer_result
		[ -n $__searching ] && unset __searching
		[ -n $dmsg ] && unset dmsg
		[ -n $delaymotd ] && unset delaymotd
		[ -n $gitdirty ] && unset gitdirty
	fi
	if [[ $BUFFER = *(nano|vi|less|hist|man|ssh|suroot)* ]]; then # Buffer contains these programs
		typeset -g nocmdtime=1 # Blacklist programs from CMDTIME
	else
		unset nocmdtime
	fi
	zle .accept-line # Run builtin accept-line
}
zle -N accept-line

# Print a usage for these functions
funcs() {
	print "## Useful functions loaded in fpath ##\n"

	print "d		Show/add to directory stack"
	print "mkcd 		Make directory and cd into it"
	print "cdls 		Change to a directory and list contents\n"

	print "bgc		Print background color chart"
	print "fgc		Print foreground color chart\n"

	print "bu		Backup a file with a timestamp and create a copy with preserved attributes"
	print "Usage: 		bu [filename] [log]"
	print " or		bu [log|logclear]"
	print "Options:"
	print " filename	Filename to backup"
	print " log [arg1] 	Print backup log"
	print " log [arg2] 	(Optional) log backup date and filename to "$ZSH"/.zbulog"
	print " logclear	Clear backup log\n"

	print "extract		Extract an archive based on the file extension"
	print "Usage: 		extract [filename]\n"

	print "findstr		Find a file containing a string"
	print "Usage: 		findstr [directory] [string]"
	print "Options:"
	print " directory	(Optional) directory to search. If not supplied then current directory is used."
	print " string 	String to search\n"

	print "gacp		Git add file, commit a message and push with one command."
	print "Usage:		gacp [filename] [message]"
	print "Options:"
	print " filename	(Optional) files to add. If not used then all modified files are added (git add -A)"
	print " message	Commit message. Recommened to quote the message.\n"

	print "gcu 		Git undo last commit and return HEAD to previous state\n"

	print "rmdss		[macOS] Remove .DS_Store files recursively"
	print "Usage:		rmdss [directory]"
	print "Options:"
	print " directory	(Optional) directory to search. If not supplied then current directory is used.\n"

	print "deploymsg	Display a message below the prompt. This is calling a Zplugin builtin function.\n"

	print "weather		Show the current weather conditions using wttr.in"
	print "forecast	Show the weather forecast using wttr.in\n"

	print "zsht		Profile zsh startup time. Uses zsh install location from PATH.\n"

	print "## Keybind functions\n"

	print "clear_screen()	[Ctrl+L] Customize builtin clear-screen widget to assist with prompt tasks"
	print "kill_line()	[Ctrl+U] Customize builtin kill-line widget to assist with prompt tasks"
	print "fancy_ctrl_z()	[Ctrl+Z] Move current program to background/foreground"
	print "nano_cmdline()	[Ctrl+X, E] Edit prompt in nano"
	print "scroll_pgup()	[Ctrl+K] Page up half a page and keep scrollback\n"

	print "## Functions automatically loaded and not user invoked\n"

	print "accept-line()	Customized builtin accept-line widget to assist with prompt tasks"
	print "auto_venv()	Auto activate/deactivate virtual environment when cd-ing into/out of a virtualenv"
	print "fuck()		Load thefuck plugin"
	print "silentjob()	Load a silent background job - runs randtimer()"
	print "randtimer()	Run on a random schedule between tMin and tMax hrs - runs fortune by default"
}

